package com.beanvulnerable.aeg;

import com.beanvulnerable.aeg.domain.ClassAnalysis;
import com.beanvulnerable.aeg.domain.DataFlowSink;
import com.beanvulnerable.aeg.domain.DataFlowSource;
import com.beanvulnerable.aeg.domain.MethodAnalysis;
import com.beanvulnerable.aeg.domain.Vulnerability;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Heuristic vulnerability detector used when symbolic execution is unavailable.
 * It flags a sink as vulnerable when any source is present in the same method.
 */
public class HeuristicVulnerabilityDetector {

    public List<Vulnerability> detect(ClassAnalysis analysis) {
        if (analysis == null) {
            return Collections.emptyList();
        }

        List<Vulnerability> vulnerabilities = new ArrayList<>();
        for (Map.Entry<String, MethodAnalysis> entry : analysis.getMethodAnalyses().entrySet()) {
            MethodAnalysis method = entry.getValue();
            Set<DataFlowSource> sources = method.getSources();
            Set<DataFlowSink> sinks = method.getSinks();

            if (sources == null || sources.isEmpty() || sinks == null || sinks.isEmpty()) {
                continue;
            }

            for (DataFlowSink sink : sinks) {
                DataFlowSource source = sources.iterator().next();
                String description = "Heuristic source-to-sink flow in " + method.getMethodName();
                vulnerabilities.add(new Vulnerability(
                    source.getSourceId(),
                    sink.getSinkId(),
                    sink.getSinkType(),
                    sink.getSinkType(),
                    description,
                    Collections.emptyList()
                ));
            }
        }

        return vulnerabilities;
    }
}
