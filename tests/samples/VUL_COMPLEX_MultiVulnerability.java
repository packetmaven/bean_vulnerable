import javax.servlet.http.*;
import java.sql.*;
import java.io.*;
import java.util.*;
import javax.xml.parsers.*;
import org.w3c.dom.*;
import java.security.*;
import javax.crypto.*;
import javax.crypto.spec.*;
import java.util.concurrent.*;
import java.lang.reflect.*;

/**
 * Complex Multi-Vulnerability Test Case
 * 
 * This file contains multiple interacting vulnerabilities to test:
 * 1. Interprocedural taint flow tracking
 * 2. Implicit flow detection through conditionals
 * 3. Context-sensitive analysis across multiple call chains
 * 4. Path-sensitive vulnerability detection
 * 5. Alias analysis with complex object graphs
 * 6. Field-sensitive taint tracking
 * 
 * Expected Detections:
 * - SQL Injection (taint flow through multiple methods)
 * - Command Injection (conditional execution path)
 * - XXE (XML External Entity)
 * - Weak Cryptography (DES usage)
 * - Path Traversal (file operation with user input)
 * - Insecure Deserialization
 * - Race Condition (shared resource access)
 * - Integer Overflow (in array allocation)
 * - Resource Leak (unclosed streams)
 */
public class VUL_COMPLEX_MultiVulnerability {
    
    // Shared state for race condition
    private static Map<String, UserSession> sessionCache = new HashMap<>();
    private static int requestCounter = 0;
    
    // Inner class for field-sensitive analysis
    private static class UserSession implements Serializable {
        String username;
        String sessionToken;
        List<String> permissions;
        Map<String, Object> metadata;
        
        UserSession(String user, String token) {
            this.username = user;
            this.sessionToken = token;
            this.permissions = new ArrayList<>();
            this.metadata = new HashMap<>();
        }
    }
    
    // Entry point: Complex request handler with multiple vulnerability paths
    public void handleComplexRequest(HttpServletRequest request, HttpServletResponse response) 
            throws Exception {
        
        // Taint source: User input from multiple sources
        String userId = request.getParameter("userId");
        String action = request.getParameter("action");
        String data = request.getParameter("data");
        String xmlContent = request.getParameter("xmlData");
        
        // Path 1: Conditional execution leading to SQL injection (implicit flow)
        if (authenticate(userId)) {
            // Taint flows into SQL query through multiple methods
            String userRole = getUserRole(userId);
            processUserAction(action, userId, userRole);
        }
        
        // Path 2: XML processing vulnerability
        if (xmlContent != null && !xmlContent.isEmpty()) {
            parseXMLConfig(xmlContent);
        }
        
        // Path 3: File operations with path traversal
        String filename = request.getParameter("filename");
        if (filename != null) {
            readUserFile(userId, filename);
        }
        
        // Path 4: Weak cryptography for sensitive data
        String sensitiveData = request.getParameter("creditCard");
        if (sensitiveData != null) {
            String encrypted = weakEncrypt(sensitiveData, userId);
            storeEncryptedData(userId, encrypted);
        }
        
        // Path 5: Deserialization of untrusted data
        String serializedSession = request.getParameter("session");
        if (serializedSession != null) {
            UserSession session = deserializeSession(serializedSession);
            processSession(session);
        }
        
        // Path 6: Command injection through reflection
        String className = request.getParameter("handler");
        if (className != null) {
            invokeHandler(className, data);
        }
        
        // Path 7: Race condition on shared state
        updateSessionCache(userId, action);
        
        // Path 8: Integer overflow in buffer allocation
        String bufferSize = request.getParameter("bufferSize");
        if (bufferSize != null) {
            allocateUserBuffer(Integer.parseInt(bufferSize));
        }
    }
    
    // Vulnerability 1: SQL Injection through interprocedural flow
    private boolean authenticate(String userId) throws SQLException {
        Connection conn = null;
        Statement stmt = null;
        
        try {
            conn = DriverManager.getConnection("jdbc:mysql://localhost/users", "root", "password");
            stmt = conn.createStatement();
            
            // Tainted userId flows into SQL query
            String query = "SELECT * FROM users WHERE id = '" + userId + "'";
            ResultSet rs = stmt.executeQuery(query);  // SQL INJECTION
            
            return rs.next();
        } finally {
            // Resource leak: stmt and conn not closed in all paths
            if (stmt != null) stmt.close();
        }
    }
    
    private String getUserRole(String userId) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/users", "root", "password");
        
        // Another SQL injection point with tainted data
        String query = "SELECT role FROM user_roles WHERE user_id = " + userId;
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(query);  // SQL INJECTION
        
        if (rs.next()) {
            return rs.getString("role");
        }
        return "guest";
        // Resource leak: connections not closed
    }
    
    private void processUserAction(String action, String userId, String role) throws SQLException {
        if (role.equals("admin")) {
            // Implicit flow: tainted userId used conditionally
            Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/audit", "root", "password");
            
            // Context-sensitive: tainted through multiple call chain
            String auditQuery = "INSERT INTO audit_log VALUES ('" + userId + "', '" + action + "')";
            Statement stmt = conn.createStatement();
            stmt.executeUpdate(auditQuery);  // SQL INJECTION via implicit flow
        }
    }
    
    // Vulnerability 2: XXE (XML External Entity)
    private void parseXMLConfig(String xmlContent) throws Exception {
        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
        // No external entity protection
        DocumentBuilder builder = factory.newDocumentBuilder();
        
        InputStream stream = new ByteArrayInputStream(xmlContent.getBytes());
        Document doc = builder.parse(stream);  // XXE VULNERABILITY
        
        processXMLDocument(doc);
        // Resource leak: stream not closed
    }
    
    private void processXMLDocument(Document doc) {
        NodeList nodes = doc.getElementsByTagName("config");
        for (int i = 0; i < nodes.getLength(); i++) {
            Node node = nodes.item(i);
            // Process configuration
        }
    }
    
    // Vulnerability 3: Path Traversal
    private void readUserFile(String userId, String filename) throws IOException {
        // Tainted filename allows directory traversal
        String basePath = "/var/data/users/" + userId + "/";
        File file = new File(basePath + filename);  // PATH TRAVERSAL
        
        FileInputStream fis = new FileInputStream(file);
        BufferedReader reader = new BufferedReader(new InputStreamReader(fis));
        
        String line;
        while ((line = reader.readLine()) != null) {
            processFileLine(line);
        }
        // Resource leak: reader and fis not closed
    }
    
    private void processFileLine(String line) {
        // Process file content
    }
    
    // Vulnerability 4: Weak Cryptography (DES)
    private String weakEncrypt(String data, String key) throws Exception {
        // Using weak DES algorithm
        KeyGenerator keyGen = KeyGenerator.getInstance("DES");  // WEAK CRYPTO
        keyGen.init(56);
        SecretKey secretKey = keyGen.generateKey();
        
        Cipher cipher = Cipher.getInstance("DES/ECB/PKCS5Padding");  // WEAK MODE
        cipher.init(Cipher.ENCRYPT_MODE, secretKey);
        
        byte[] encrypted = cipher.doFinal(data.getBytes());
        return Base64.getEncoder().encodeToString(encrypted);
    }
    
    private void storeEncryptedData(String userId, String encrypted) throws SQLException {
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/secure", "root", "password");
        
        // Another SQL injection with tainted userId
        String query = "INSERT INTO encrypted_data VALUES ('" + userId + "', '" + encrypted + "')";
        Statement stmt = conn.createStatement();
        stmt.executeUpdate(query);  // SQL INJECTION
    }
    
    // Vulnerability 5: Insecure Deserialization
    private UserSession deserializeSession(String base64Session) throws Exception {
        byte[] data = Base64.getDecoder().decode(base64Session);
        ByteArrayInputStream bais = new ByteArrayInputStream(data);
        ObjectInputStream ois = new ObjectInputStream(bais);
        
        // Deserializing untrusted data
        UserSession session = (UserSession) ois.readObject();  // INSECURE DESERIALIZATION
        
        return session;
        // Resource leak: ois not closed
    }
    
    private void processSession(UserSession session) {
        // Tainted session object fields used in operations
        if (session != null && session.username != null) {
            // Field-sensitive taint tracking
            sessionCache.put(session.username, session);
        }
    }
    
    // Vulnerability 6: Reflection Injection / Command Injection
    private void invokeHandler(String className, String data) throws Exception {
        // Reflection with user-controlled class name
        Class<?> handlerClass = Class.forName(className);  // REFLECTION INJECTION
        Method method = handlerClass.getMethod("handle", String.class);
        Object instance = handlerClass.newInstance();
        
        // Tainted data passed to dynamically loaded code
        method.invoke(instance, data);
        
        // Additional command injection risk
        if (className.contains("System")) {
            Runtime.getRuntime().exec("handler_" + data);  // COMMAND INJECTION
        }
    }
    
    // Vulnerability 7: Race Condition
    private void updateSessionCache(String userId, String action) {
        // Unsynchronized access to shared state
        requestCounter++;  // RACE CONDITION
        
        UserSession session = sessionCache.get(userId);
        if (session == null) {
            session = new UserSession(userId, generateToken());
            sessionCache.put(userId, session);  // RACE CONDITION
        }
        
        // Time-of-check to time-of-use vulnerability
        if (session.permissions.size() < 10) {
            session.permissions.add(action);  // RACE CONDITION
        }
    }
    
    private String generateToken() {
        // Insecure random number generation
        Random random = new Random();  // INSECURE RANDOMNESS
        return Long.toHexString(random.nextLong());
    }
    
    // Vulnerability 8: Integer Overflow
    private byte[] allocateUserBuffer(int multiplier) {
        int headerSize = 1024;
        int userSize = multiplier * 1000;
        
        // Potential integer overflow in buffer allocation
        int totalSize = headerSize + userSize;  // INTEGER OVERFLOW
        byte[] buffer = new byte[totalSize];  // Can allocate huge/negative buffer
        
        return buffer;
    }
    
    // Complex alias analysis test: object graph with multiple references
    private void testAliasAnalysis(String userId) throws Exception {
        UserSession session1 = new UserSession(userId, "token1");
        UserSession session2 = session1;  // Alias relationship
        UserSession session3 = new UserSession(userId, "token2");  // Distinct allocation
        
        // Field updates through aliases
        session2.metadata.put("lastAccess", new java.util.Date());
        
        // Should track that session1.metadata and session2.metadata are aliased
        if (session1.metadata.containsKey("lastAccess")) {
            String query = "UPDATE sessions SET last_access = NOW() WHERE user_id = '" + userId + "'";
            // SQL injection through complex alias chain
        }
    }
}

